-- MILESTONE 1: DATABASE DESIGN IMPLEMENTATION
-- Adapted for PostgreSQL (Supabase) from the provided requirements.

-- 1. USERS TABLE
-- Stores user profiles. Links to Supabase Auth via 'auth_id' to ensure login works.
create table if not exists public.users (
  user_id bigint generated by default as identity primary key, -- Auto-incrementing Integer PK
  auth_id uuid not null, -- Mock Data Link (Removed FK to auth.users to allow fake records)
  full_name varchar(100) not null,
  email varchar(100) unique not null,
  dob date,
  student_id varchar(50) not null,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- 2. API_CONFIGS TABLE
-- Supports BYOAPI and Local Network Configurations
create table if not exists public.api_configs (
  config_id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id) on delete cascade not null,
  provider varchar(20) not null,
  base_url varchar(255) default 'http://localhost:11434',
  api_key varchar(255),
  constraint chk_provider check (provider in ('Ollama', 'OpenAI', 'Groq', 'DeepSeek', 'Mistral AI', 'Other'))
);

-- 3. PERSONAS TABLE
-- AI Character Definitions
create table if not exists public.personas (
  persona_id bigint generated by default as identity primary key,
  config_id bigint references public.api_configs(config_id) on delete set null, -- Optional config link
  user_id bigint references public.users(user_id) on delete cascade, -- Allow users to own personas
  persona_name varchar(50) not null,
  system_prompt text not null
);

-- 4. CHAT_SESSIONS TABLE
-- Session Management
create table if not exists public.chat_sessions (
  session_id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id) on delete cascade not null,
  persona_id bigint references public.personas(persona_id) on delete set null,
  session_title varchar(200),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 5. MESSAGES TABLE
-- Interaction Logs
create table if not exists public.messages (
  message_id bigint generated by default as identity primary key,
  session_id bigint references public.chat_sessions(session_id) on delete cascade not null,
  sender_role text not null check (sender_role in ('user', 'assistant')),
  content text not null,
  msg_time timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 6. KNOWLEDGE_BASE TABLE
-- Saved Information for RAG/Research
create table if not exists public.knowledge_base (
  entry_id bigint generated by default as identity primary key,
  user_id bigint references public.users(user_id) on delete cascade not null,
  topic varchar(100),
  data_content text,
  created_at timestamp with time zone default timezone('utc'::text, now())
);

-- ENABLE ROW LEVEL SECURITY (RLS)
alter table public.users enable row level security;
alter table public.api_configs enable row level security;
alter table public.personas enable row level security;
alter table public.chat_sessions enable row level security;
alter table public.messages enable row level security;
alter table public.knowledge_base enable row level security;

-- DROP EXISTING POLICIES (To avoid "already exists" errors)
drop policy if exists "Users manage own profile" on public.users;
drop policy if exists "Users manage own configs" on public.api_configs;
drop policy if exists "Users view public personas" on public.personas;
drop policy if exists "Users manage own personas" on public.personas;
drop policy if exists "Users manage own sessions" on public.chat_sessions;
drop policy if exists "Users manage own messages" on public.messages;
drop policy if exists "Users manage own knowledge" on public.knowledge_base;

-- CREATE POLICIES (Users can only see their own data)
-- Users
create policy "Users manage own profile" on public.users
  for all using (auth.uid() = auth_id);

-- API Configs
create policy "Users manage own configs" on public.api_configs
  for all using (
    exists (select 1 from public.users where public.users.user_id = public.api_configs.user_id and public.users.auth_id = auth.uid())
  );

-- Personas (Shared + User Owned)
create policy "Users view public personas" on public.personas
  for select using (user_id is null); -- Public personas have null user_id

create policy "Users manage own personas" on public.personas
  for all using (
    exists (select 1 from public.users where public.users.user_id = public.personas.user_id and public.users.auth_id = auth.uid())
  );

-- Chat Sessions
create policy "Users manage own sessions" on public.chat_sessions
  for all using (
    exists (select 1 from public.users where public.users.user_id = public.chat_sessions.user_id and public.users.auth_id = auth.uid())
  );

-- Messages
create policy "Users manage own messages" on public.messages
  for all using (
    exists (
      select 1 from public.chat_sessions
      join public.users on public.chat_sessions.user_id = public.users.user_id
      where public.messages.session_id = public.chat_sessions.session_id
      and public.users.auth_id = auth.uid()
    )
  );

-- Knowledge Base
create policy "Users manage own knowledge" on public.knowledge_base
  for all using (
    exists (select 1 from public.users where public.users.user_id = public.knowledge_base.user_id and public.users.auth_id = auth.uid())
  );

-- TRIGGER: Automatically create User Profile on Signup
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.users (auth_id, full_name, email, student_id)
  values (new.id, new.raw_user_meta_data->>'full_name', new.email, 'STUDENT-' || substr(new.id::text, 1, 8));
  return new;
end;
$$ language plpgsql security definer;

-- Trigger event (Drop if exists to avoid error on rerun)
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
